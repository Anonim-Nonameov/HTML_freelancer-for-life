/* Урок №4 - CSS псевдоэлементы: before и другие. */

/*
Сегодня наш разговор пойдет о псевдоэлементах! псевдоэлементы могут с помощью CSS обратиться
к содержимому, или к части содержимого объекта, а также добавить новые объекты! сейчас мы со
всем разберемся и научимся всему необходимому :) но нам для начала необходимо хоть как-то да
застилизовать наш HTML файл, а то он выглядит уж больно скучным! ну так чего медлить? приступаем!
*/

body {
	padding: 30px;
}

.text {
	font-size: 24px;
	line-height: 33px;
	margin: 0 0 30px 0;
}

.list li {
	font-size: 24px;
	margin: 0 0 20px 0;
}

/*
Синтаксис написания псевдоэлементов крайне схож с синтаксисом написания псевдоклассов, и это в общем-то
даже неудивительно - у них даже названия очень похожи, синтаксис что-ли будет отличаться? ага, щас :D
Ну на крайний случай вот вам: идет обращение к селектору класса, либо к селектору типа, затем ставится двое-
точие и только после него идет название псевдоэлемента. С приходом CSS3 стало возможно добавлять сразу двое-
точия вместо одного, что очень даже удобно, ведь таким образом мы сможем различать псевдоклассы и псевдоэле-
менты, если у нас в файле активно используются как первые (п-классы), так и вторые (п-элементы). Как-то так!

А теперь пора переходить непосредственно к псевдоэлементам! Встречайте - ::first-line
Псевдоэлемент first-line позволяет задать стили для первой строки текста. Интересно, не так ли? давайте
применим его к нашему параграфу с классом .text, там у нас как раз много текста и строк будет не мало:
*/

.text::first-line {
	color: green;
}

/*
Заходим в браузер и смотрим: наша первая строка в параграфе действительно изменилась! она стала.. больной!
Ой, в смысле... зеленой! сколько бы у нас не было строк в нашем параграфе, только первая строка будет такой,
ни вторая, ни третья, ни четвертая и даже пятая строка не станет зеленой - быть такого цвета суждено только
первой, и никому больше. Это легко проверить: откройте браузер и начните "сжимать" окошко, создав таким об-
разом сразу много строк - что нибудь изменилось? вы скажете "нет", и вы будете правы! лишь первая строка ос-
талась зеленой, другие не изменились.

Идем дальше, к следующему псевдоэлементу - ::first-letter
Псевдоэлемент first-letter позволяет задать стили для первой буквы, первого символа в абзаце, причем не важ-
но, сколько абзацев у нас есть на сайте - если у нас есть три абзаца с каким-то определенным классом, и мы
задали для них с помощью псевдоэлемента first-letter красный цвет (дабы у нас первые буквы в абзацах стали
красного цвета), то у каждого абзаца первая буква станет красного цвета. Это то мы и сделаем! но мы сделаем
не только это - мы еще и изменим размер первой буквы:
*/

.text::first-letter {
	font-size: 50px;
	color: red;
}

/*
Заходим в браузер, смотрим: а там у нас первую букву в абзаце от злости раздуло! да так раздуло, что она
больше основного текста в 2 раза! но не суть, главное что мы (вы, читатель, и я) поняли, что мы можем при
помощи псевдоэлемента просто так взять и создать что-то на подобие красной строки, БЕЗ использования чего
то лишнего в самом HTML. И осталось добавить, что к псевдоэлементам ::first-line и ::first-letter допустимо
использовать только те свойства, которые относятся либо к шрифту, изменению цвета текста и фона.

Идем дальше, разбирая псевдоэлементы как горячие пирожки... но стоп! у меня тут важнОя инфмАрмацЫя.
Те псевдоэлементы, которые мы изучим дальше, отличаются от предыдущих - они добавляют якобы целый тег, до
или после тега, к которому мы обращаемся. Но о чем идет речь и о чем вообще я? допустим, что я хочу стили-
зовать свой маркированный список. Мы с вами уже знаем, что это мощно сделать через свойство background, но
сегодня мы научимся делать это используя псевдоэлементы. Итак, встречайте! - ::before

Псевдоэлементыч ::before используется для отображения желаемого контента ДО содержимого элемента, к кото-
рому он применяется. Используется п-элемент ::before ТОЛЬКО со свойством «content:  '';», без него он не
будет отображаться в браузере. Свойство content может иметь пустое значение, то бишь просто пустые кавычки.
Однако оно как раз таки и содержит в себе тот самый контент, который мы хотим вывести ДО тега, к которому
мы применим этот псевдоэлемент. Контент вставляется внутрь кавычек, как вы уже, наверное, догадались.
Сразу для, так сказать, наглядности, я покажу вам следующий псевдоэлемент - ::after

Этот псевдоэлемент применяется для отображения желаемого контента ПОСЛЕ содержимого элемента, к которому
он применяется. Т.е этот псевдоэлемент делает то же самое что и ::before, только действует он наоборот -
если ::before использовался для отображения контента ДО нашего тега, то ::after используется для отобра-
жения контента ПОСЛЕ нашего тега. Так-то всё логично: before переводится как "до", after как "после" :)
Используется п-элемент ::after также как и ::before, только со свойством content. В принципе всё также
логично, так как оба этих п-элемента одинаковы и делают почти одну и ту же работу. А теперь будем применять
эти п-элементы на практике! а применять мы будем их на нашем списке. ::before мы применим для того, чтобы
до наших тегов li появлялись вот такие вот открывающие кавычки: «, а для чего мы будем использовать только
что изученный п-элемент ::after я думаю вы уже догадались :)
*/

.list li::before {
	content: "«";
}

.list li::after {
	content: "»";
}

/*
Готово! мы смогли ИЗМЕНИТЬ наш HTML файл НЕ ДОБАВЛЯЯ к нему ничего внутри, сделав это через CSS файл!
А теперь я покажу вам, читатель, дополнительные возможности, которые открываются нам благодаря этим
прекрасным псевдоэлементам. Теперь я хочу по другому стилизовать наш список, для этого мы "обнулим"
всё то, что сделали ранее:
*/

.list li::before, .list li::after {
	content: ""; /* обнуляшки!! */
}

/*
Отлично! теперь к сути. Я хочу сделать СВОИ маркеры для элементов списка! для этого, во первых, мы
задаем нашим li'шкам display со значением inline-block. Зачем? из прошлых уроков мы знаем, что display
со значеним inline-block оставляет за элементом его строчные харакетеристики, а именно что элемент будет
выставлен в строку, как и другие строчные элементы, но на него будут действовать все свойства, применимые
исключительно для блочных элементов, например: ширина, высота и так далее. Дальше мы задаем ширину и
высоту в 10 пикселей (слишком большие круги нам не нужны), border-radius со значеним 50% для скругления
получившихся квадратов (без этого свойства это будут квадраты), и цвет фона - красный:
*/

.list li::before {
	content: "";
	display: inline-block;
	width: 10px;
	height: 10px;
	border-radius: 50%;
	background-color: #f00;
}

/*
Зашли в браузер, посмотрели: всё получилось! возле наших элементов li появились те самые красные маркеры,
но есть одна проблема - маркеры через чур прижаты к нашим элементам. Не хорошо, не хорошо. Необходимо
задать свойству margin такое значение: "0 10px 0 0", чтобы появился отступ от этих кружков. Применять
это свойство будем к самим кружкам:
*/

.list li::before {
	content: "";
	margin: 0 10px 0 0;
}

/*
Всё, теперь точно всё готово! грубо говоря, мы ДОБАВИЛИ еще один некий тег до наших элементов li, имитируя
маркеры, и всё это без всяких background'ов, фонов, картинок и прочего - мы всего лишь использовали один
псевдоэлемент, а получилась такая красота! и естественно, как ты, читатель, понимаешь, возможности тут
просто безграничны - можно таким образом стилизировать что угодно и как угодно, добавлять п-элементы как
до, так и после уже самих элементов, НАСТОЯЩИХ. П-элементы ::before и ::after используются крайне часто,
так как это действительно мощный и очень полезный инструмент, и часто их используют в совокупности с
позиционированием, о котором мы будем говорить (я буду писать) в одном из следующих уроков. Пока что
достаточно знать, что эти "штуки" - очень мощные инструменты, и широко применяются верстальщиками.

Также существуют так называемые "специфические" псевдоэлементы. О чем идет речь? - загляните в файл
index.html, найдите там input в самом низу. Нашли? хорошо! а я пока что возьму и стилизирую этот инпут:
*/

.input {
	width: 220px;
	height: 40px;
	border: 1px solid #000;
	padding: 0 0 0 10px;
}

/*
Отлично! теперь перейдем непосредственно "к мясу". Зайдите в файл main__resetter.css и закомментируйте
код на 31 строке. Идем дальше - если у вас, читатель, есть Internet Explorer, то зайдите в него и откройте
файл index.html в нем. У вас появится та же самая (из-за "старости" браузер может отобразить что-то не так)
страничка, а вместе с ней - input. Нажимте на него и введите какой нибудь текст, любой. Вы увидите, что у
вас появился маленький крестик внутри него, нажав на который вы можете стереть всё то, что написали.
Дело в том, что заказчики когда такое видят, говорят примерно такое (со слов Жеки): "что это такое?! такого
в макете не было! уберите немедленно!!", нагоняют шуму короче :D, так вот - чтобы убрать этот крестик, Жека
специально для нас перерыл весь интернет и узнал про "специфические псевдоэлементы", а я пересказываю это
вам. Так вот - чтобы избавиться от этого крестика, надо использовать п-элемент -ms-clear. ms судя по всему
означает MicroSoft, потому что работает только для интернет эксплорера, но не суть. Суть в том, что нам надо
применить этот псевдоэлемент непосредственно к инпуту и добавить в фиг. скобки свойство display со значением
none, дабы скрыть этот "не красивый" крестик. Это мы уже делали в нашем обнуляющем стиле (именно поэтому
я попросил вас, читатель, закомментировать код на 31 строке, дабы увидеть крестик в IE), но я перезапишу
весь этот код здесь, так будет нагляднее:
*/

.input::-ms-clear {
	display: none;
}

/*
Готово! мы избавились от крестика. Но так ли это на самом деле (то что он удаляет крестик) - я понятия не
имею, хотя в уроке было видно, что да, крестик удалился. Просто сейчас работа этого псевдоэлемента была
прекращена, а я об этом ничего не знаю. Хотя.. кто сейчас, в 2021 году, пользуется IE? :D

Есть еще один специфический п-элемент, находится он также в стиле-обнуляшке, на 33 строке. Сам по себе
псевдоэлемент называется -moz-focus-inner, и приставка "moz" означает то, что работать он будет только
в браузере Firefox. А так этот псевдоэлемент добавляет отступы и рамки для кнопок, а мы их что делаем?
правильно, правильно - убираем! нам лишнее не нужно, всё от себя добавим и еще чем нибудь угостим :)

А на этом всё - задание в папке "Задания" :)

*/