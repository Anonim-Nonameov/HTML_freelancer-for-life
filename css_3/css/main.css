/* Урок №3 - CSS свойства блоков. padding, margin, display. */	

/*
!!ВАЖНОЯ ИНФАРМАЦЫЯ!!!

Урок идет целых полчаса, поэтому я буду писать всё это очень долго.
Конспекта много, и писать надо не меньше.
Займет все это примерно 2 дня, может больше. Но я постараюсь уложиться в 2 дня.
*/

/* 
У блоков (блочных элементов) в CSS есть специальные свойства, padding и margin.

padding - это внутренний отступ у блочного тега. Т.е, когда мы задаем padding у n-ного элемента,
то все внутренние элементы тоже сдвигаются!

Синтаксис прост:

padding: 5px 10px 15px 20px;

Отступ в пять пикселей будет сверху, десять пикселей справа, снизу пятнадцать, двадцать слева.
Иногда можно запутаться во всём этом, и проще всё это объяснить на примере наручных часов:

Первое значение у padding - отступ сверху. На часах сверху всегда 12, это 1-ое значение на часах.
А это значит, что первое значение у padding отвечает за отступ сверху. Это надо запомнить!
Далее второе значение, отступ справа. На часах справа всегда цифра 3 - значит второе значение
padding отвечает за отступ справа. Запоминаем!
Далее третье значение, отступ снизу. На часах снизу всегда цифра 6 - значит третье значение
padding отвечает за отступ снизу. Запомнили!
И последнее, четвертое значение - отступ слева. На часах слева всегда цифра 9 - значит четвертое
значение padding отвечает за отступ слева. Также запомнили!

Здесь главное понять как это работает, вот и всё.
Я сам частенько забываю, какое значение за какое направление отвечает - пример с часами помогает!)
*/

.example-block {
	padding: 10px 20px 30px 5px;
	/* Жека не рассказывал про свойство border, добавил для наглдяности. Вот и я добавил. */
	border: 1px solid #000;
}

/*
Итак: 10 пикселей сверху, 20 справа, 30 снизу, 5 слева.
Убедиться в том, что всё работает - можно закомментировав padding и посмотрев на браузер.
Когда мы зайдем в браузер, то увидим, что граница "прилипает" к тексту, а благодаря padding - держится
"в сторонке" от нашего текста. Боится :) 

Но что если мы укажем не 4 знаения, а 3? например, вот так:
padding: 10px 20px 30px;

Тогда произойдет вот что: 10 пикселей сверху, 20 пикселей и справа и слева, 30 пикселей снизу.
Всё дело в том, что мы убрали значение "5px", а это отвечает за отступ в 5 пикселей слева,
поэтому оно было заменено на 20px (т.к 20px это отступ справа). "Справа" поделился своими пикселями с "слева" :D
*/

.example-block {
	padding: 10px 20px 30px;
}

/*
З.Ы - вы не увидите изменений, а увидите последнее значение у .example-block - работает переопределение.
Если вам, читатель, надо узнать как работает паддинг - переопределите .example-block и поиграйтесь
со значениями padding, удаляя и добавляя значения также как и я.
*/

/*
Хорошо, а что если мы уберем и третье значение? например, вот так:
padding: 10px 20px;
Тогда будет так: 10 пикселей снизу и сверху, 20 пикселей справа и слева.
Мы убрали значение "30px", а это отступ снизу. Поэтому, было взято значение у 10px (а это отступ сверху).

*/

.example-block {
	padding: 10px 20px;
}

/*
А что если оставить только одно значение? например, вот так:
padding: 10px;
Тогда во как будет? 10 пикселей снизу, сверху, справа и слева. Всё дело в том, что больше значения "20xpx"
больше нету, соответственно нету отступов справа и слева. Поэтому было взято у 10px, т.к это единственное
доступное значение в коде.
*/

.example-block {
	padding: 10px;
}

/*
И в конце концов - значения свойства padding не может быть отрицательным, и еще: паддинги работают
исключительно для блоков (то есть для блочных элементов).

Но всё давайте посмотрим на то, что же будет с нашим строчным элементом с паддингом:
*/

.example-string {
	padding: 20px;
	/* border: 1px solid #000000 */
}

/*
Если зайти в браузер и посмотреть на то, что же произошло - можно заметить, что сдвинулась лишь первая
строчка в теге span. Почему? а я не знаю как объяснить, проще посмотреть в консоли разработчика (включить
её можно при помощи хоткея: CTRL + Shift + I).
А что касается бордера - то он также не применим к строчным тегам, и если применить его вкупе с паддингами - будет
какой-то кошмар, всё станет похожим на свастику (я серьезно). А без паддингов, бордер просто будет сильно прижат к
нашему тексту в span.

И я забыл упомянуть, что значения паддингов могут задаваться не только в пикселях, их можно задавать в разных
единицах измерения. Например - в процентах: 
*/

.example-block {
	padding: 10%;
}

/*
В таком случае, значения паддингов будут равны десяти процентам от ширины родителя, то бишь от ширины окна браузера.
Всё дело в том, что паддинг - внутренний отступ, а значит - будет внутри дива. Но из-за внутренних отступов,
размеры блока будет довольно большими, и если мы будем уменьшать окно браузера - будет уменьшаться и сам блок,
но паддинги всё равно будут занимать 10 процентов от ширины родителя.

Короче - 10 процентов от ширины дива, а размер дива зависит от ширины окна браузера.
Но всё же проще просто открыть браузер и начать менять ширину окна, так будет куда понятнее :)

Ну а теперь о другом, противоположном свойстве - margin, ВНЕШНИЙ отступ у блочных тегов.
Я не думаю что его стоит как-то объяснять, так как его значения те же самые, что и у паддингов.
Однако, если мы сделаем ТАК:

*/

.example-block {
	/* Чтобы вернуть паддинги на свои места */
	padding: inherit;
	margin: 10px;
}

/*
То мы увидим, что наш блок "отступил" от краев окна. Испугался :)
Это то и есть внешний отступ - внутри он никаких отступов не дает, только снаружи.

Существенное отличие паддинга и маргина в том, что у маргинов допустимы ОТРИЦАТЕЛЬНЫЕ значения.
Да-да, ОТРИЦАТЕЛЬНЫЕ. Посмотрим на пример:
*/

.example-block {
	/* Сверху и снизу внешний отступ по 10 пикселей, а справа и слева МИНУС 10 пикселей */
	margin: 10px -10px;
}

/*
Если посмотреть в браузер, то можно заметить, что наш блок.. "съехал" влево. Всё дело в том, что отрицательные
значения инвертны положительным (как бы логично это не звучало). Если мы задали 10 пикселей справа и слева - то
он отступит от краев окна на 10 пикселей, а если мы задали -10 пикселей - наоборот, будет "прижат".

А тэпэрь посмотрим его работу со строчными тегами:
*/

.example-block {
	/* Не знаю зачем, но Жека убрал все маргины у блочного тега.. но я сделаю также */
	margin: inherit;
}

.example-string {
	/* Чтобы вернуть паддинги на свои места */
	padding: inherit;
	margin: 10px;
}

/*
Если зайти в браузер, не трудно заметить, что наш текст немного сдвинулся вправо.
Всё очень просто: маргины, как и паддинги - не работают со строчными тегами.
Это всё равно что пилить дерево - ножиком для масла.

Ну а тем временем мы движемся ко следующему свойству: width.
Свойство width регулирует ширину какого-то элемента. Значения также могут быть как в пикселях, так и %.
*/

.example-block {
	width: 500px;
}

/*
Если зайти в браузер, то можно заметить, что размер нашего блока стал равен 500 пикселей.
Вообще, управлять этим свойством очень просто - написал значение, и всё.
А что касается строчных тегов - тут та же самая ситуация, что и с margin & padding.
*/

.example-string {
	width: 500px;
}

/*
ЕСЛИ МЫ ПРЯМО СЕЙЧАС ЗАЙДЕМ В БРАУЗЕР И ПЕРЕЗАГРУЗИМ СТРАНИЦУ ТО...
ничего не увидим, всё, разошлись.
На самом деле - width абсолютно никак не влияет на строчные теги. Вообще.

Но! - попробуем применить свойство width к тегу img:
*/

.example-image {
	width: 100px;
}

/*
Если мы сейчас зайдем в браузер, то увидим что наша картинка сильно уменьшилась - до 100 пикселей.

О чем нам это говорит?
А говорит это нам о том, что всё же к некоторым строчным элементам (вроде img) width всё таки применяется. 

Говорим-говорим, а о свойстве max-width - ни слова!
Следующее свойство - max-width, максимальная ширина элемента.
В принципе, объяснять о чем это свойство - глупо. Ясен пень что оно устанавливает максимальную ширину у элемента.
Т.е это такой ограничитель ширины, да и только :)
*/

.example-block {
	width: auto; /* обнуляшки!! */
	max-width: 500px;
}

/*
Если мы зайдем в браузер, то ничего нового и интересного не увидим.
Всё дело в том, что ширина нашего блока - огромна (у меня она 1216px, да-да!), и мы его просто ограничили по
ширине - тот же результат можно увидеть, если задать свойству width значение 500px, а это мы уже делали.

Ну а если говорить конкретно о свойстве, то оно лишь ограничивает ширину, а не задает её.
Но так как ширина нашего блока была большой, сработало ограничение и блок уменьшился, на самом деле
ширину задает свойство width. Если мы будем уменьшать окно браузера, блок будет уменьшаться с родителем,
а если будем увеличивать - сработет ограничение и дальше увеличиваться он не будет.

И опять же - для строчных тегов оно НЕ работает, лишь для некоторых:
*/

.example-string {
	max-width: 500px;
}

/*
Если зайти в браузер, то ничего нового там не увидеть.. всё то же самое, что-ж.

Ну, в таком случае мы идем ко следующему свойству, которое схоже с предыдущим - min-width.
Свойство min-width устанавливает минимальную ширину блочных тегов, и некоторых строчных.
Работает оно почти также как width, и почти также как и max-width - на width оно похоже потому, что свойство
устанавливает миним. ограничение на ширину - т.е, если мы зададим мин. ширину 500 пикселей, то ширина в любом
случае будет 500 пикселей, мы говорим что это будет минимумом. А почему оно похоже на max-width? всё дело в том, что оно тоже
устанавливаает ограничение, а так.. всё, больше ничем не похоже.
*/

.example-block {
	max-width: none; /* обнуляшки!! */
	min-width: 500px;
}

/*
Если мы сейчас уменьшим размер окна браузера, то наш блок не будет уменьшаться вместе с родителем - его ширина в любом
случае остается в 500 пикселей.

Хорошо, но как нам использовать max(min)-width к строчным тегам?..
Ответ: никак. Разве что к картинке, но для демонстрации надо использовать процентное значения width.
*/

.example-image {
	width: 100%;
}

/*
Не рекомендую заходить в браузер, ставя такое значение у width - глаза кровиться будут.
Всё потому что мы поставили значение 100%, а это значит что картинка будет очень широкой (на всю ширину окна). 
Сейчас объясню, зачем мы так сделали:
*/

.example-image {
	max-width: 500px;
}

/*
Если зайти в браузер и начать уменьшать окно, можно заметить - картинка уменьшается, да.. но если наоборот,
увеличивать - она останется при 500 пикселях, так как это максимум. Дальше нельзя! :)

Еще можно добавить значение min-width:
*/

.example-block {
	min-width: auto; /* Жека сказал, что нам min-width будет мешать.. я его убрал. */
}

.example-image {
	min-width: 300px;
}

/*
Если уменьшать окна браузера, и дойти до 300 пикселей - уже (ударение на у) оно не станет из-за ограничения.
А если наоборот, увеличивать - шире 500-ста пикселей оно не станет из-за того же ограничения :)

Идем дальше - свойство height.
Если вы (читатель) хоть немного знаете Английский, то понять о чем это свойство не составим вам труда.
Ну а так - оно устанавливает высоту для элемента, также как и width устанавливает ширину.
Применим же его на практике!
*/

/* Жека убрал - и я уберу! */

.example-image {
	width: auto;
	min-width: auto;
	max-width: auto;
}

.example-block {
	width: auto; /* обнуляшки!! */
	min-width: auto; /* обнуляшки!! */
	max-width: none; /* обнуляшки!! */
	height: 200px;
}

/*
Заходим в браузер - видим, что высота блока равна 200 пикселям, несмотря на то что текста в нем не так уж и много.
К тому же, мы можем устанавливать значение height в процентах, например 50%:
*/

.example-block {
	height: 50%;
}

/*
Если мы сейчас зайдем в браузер, то заметим, что блок с текстом занял 50% высоты нашего окна.
Это нормально, мы ж задали height значение в 50%!
Если же мы зададим значение в 100 процентов, то блок займет собой всё окно браузера по высоте.

А теперь применим это же свойство к строчным тегам (тегУ):
*/

.example-string {
	height: 220px;
}

/*
Заходим в браузер - ничего нового не видим.
Это свойство к строчным тегам не работает, никакого эффекта от него мы не увидим.
Нооооооо - к некоторых оно всё же работает! применим его к картинке:
*/

.example-image {
	height: 100px;
}

/*
Заходим в браузер - видим, что наша картинка сильно уменьшилась!
Свойство height вполне применимо к изображениям, да и у тех есть такие же свойства - width и height.

Следующее свойство - то же самое что и max-width: max-height, встречайте!
Объяснять принцип его работы я не буду, ясен пень что он устанавливает ограничение на высоту.
*/

.example-string {
	height: auto; /* обнуляшки!! */
}

.example-image {
	height: auto; /* обнуляшки!! */
}

.example-block {
	height: auto; /* обнуляшки!! */
	max-height: 100px;
}

/*
!!!ВАЖНОЯ ИНФАРМАЦЫЯ!!!
Так, стоп - хотите увидеть изменения? заходите в HTML файл и расскоментируйте текст в блоке .example-block!

Заходим в браузер - видим какую-то кашу из текста! Всё дело в том, что текст вылез за границы своего блока, потому
что на нем стоит ограничение по высоте и увеличиться для текста он не может.
Т.е: это как наливать в стакан полный воды - еще и еще, пока не начнет вытекать!

А тем временем мы движемся к след. свойству - min-height!
Это то же самое что и min-width, единственное отличие в том, что первое устанавливает ширину, а второе - высоту.
Но, я конечно же, немножко объясню - оно установит ограничитель на мин. высоту, т.е установит высоту
принудительно в заданное значение.
*/

.example-block {
	min-height: 200px;
}

/*
Зашли в браузер, увидели - блок увеличился в высоте.
К строчному тегу span применять его не будем, т.к уже заранее знаем - не сработает.
Кстати - к изображениям его тоже не применить, не сработает.
*/

.example-block {
	min-height: auto; /* обнуляшки!! */
	max-height: none; /* обнуляшки!! */
}

.example-image {
	min-height: 200px;	
}

/*
Зашли в браузер, ничего не увидели, вышли.
Зато к изображению можно применить max-height!
*/

.example-image {
	max-height: 200px;
}


/*
ОПЯТЬ зашли в браузер, посмотрели - увидели что картинка сильно уменьшилась, т.к мы задали высоту 200 пикселей.
Но она также пропорционально уменьшилась и по ширине!.. хотя, в принципе так и должно быть - уменьшили по высоте,
почему бы не уменьшиться по ширине?

И да - в обнуляющем стиле мы ко всем элементам применили свойство box-sizing со значением border-box.
Что оно делает? - оно меняет стандартный алгоритм расчета ширины и высоты.
Вообще, меняет алгоритм значение, а не свойство... но не суть важно, не будем придираться.
По умолчанию, width и height задают ширину и высоту контента, не включая в себя значения отступов, полей и границ.
А со значением border-box, width и height ВКЛЮЧАЮТ в себя значения отступов, полей и границ НО не внешних
отступов (маргинов, margin.. ну вы поняли). 

Для примера зададим блоку ширину в 500 пикселей и паддинг, внутренний отступ - в 20 пикселей:
*/

.example-block {
	width: 500px;
	padding: 20px;
}

/*
Заходим в браузер и видим: блок ограничился по ширине, т.е ширина стала равной 500 пикселей, и контент внутри
блока отступил от границ на 20 пикселей, на указанное нами значение. Ну так вот - его ширина все равно остается
равной пятью ста пикслеям, не смотря на внутренние отступы (паддинги). Если же зайти в файл main_resetter.css и 
убрать, закомментировать следующий код: *, *:before, *:after {... box-sizing: border-box;}, то расчет ширины и
высоты вернется на стандартный, и его ширина стала 500 пикселей + левый паддинг в 20 пикселей, и + правый паддинг
в 20 пикселей = 540 пикселей! И это еще не все: если мы зададим нашему блоку маргин, со значением сверху
и снизу по нулям а справа и слева по 10 пикселей - ширина нашего блока станет 540 пикселей + левый маргин в 10
пикселей, и + правый маргин в 10 пикселей = 560 пикселей по итогу!
*/

.example-block {
	margin: 0 10px;
}

/*
Если же мы вернем обратно значение border-box, то ширина нашего блока будет равна 520-ти пикселям.
То есть, ширина блока включает в себя внутренние отступы padding, + внешние отступы margin.
Граница справа и слева - это еще + 2 пикселя слева и справа, соответсвенно при значении border-box
у свойства box-sizing граница уже включена в 500 пикселей ширины. 
Еще раз - ширина включает в себя внутренний отступ padding и границу border, но не включает в себя свойство margin.

А мы идем ко следующему свойству - overflow, управляет отображением содержимого у блочного элемента.
Значений у него много, и первое из них - visible (а это знач. по умолчанию). Оно делает так, чтобы
контент в блоке отображался даже если блок стал очень маленьким. Пример:
*/

.example-block {
	width: auto; /* обнуляшки!! */
	padding: inherit; /* обнуляшки!! */
	margin: inherit; /* обнуляшки!! */
	overflow: visible;
	max-height: 50px;
}

/*
Заходим в браузер - видим что текст вылез из блока, но продолжает отображаться.
Всё потому что мы установили значение visible у overflow! Но на самом деле - если убрать свойство overflow,
текст всё равно будет отображаться, ибо visible значение по умолчанию.

Следующее значение - hidden. При значении hidden, всё что будет выходит за рамки нашего блока - будет "исчезать",
обрезаться или просто "скрываться". 
*/

.example-block {
	overflow: hidden;
	/* Высоту не меняем */
}

/*
Выставив значение hidden, зашли в браузер и увидели, что текст.. обрезался, исчез.
Нету его больше - хоть мышкой выделяй. На самом деле значение очень удобное, например когда у нас что-то вылезает
за пределы блока и мы хотим это "скрыть".. а еще лучше просто всё исправить и не допускать более таких ошибок :)

А тем временем мы идем ко следующему значению свойства - scroll.
Работает тогда, когда текста много - высоты мало. В таком случае появляется скролл и мы можем "проскроллить" текст.
*/

.example-block {
	overflow: scroll;
}

/*
Зашли в браузер и увидели - у нашего блока появился скролл. Но больше всего интересно то, что с какого бы устройства
не смотрели на сайт (имею ввиду, что ширина и высота экрана у всех разная) - скролл всегда будет виден.
Всё потому что мы задали определенную высоту и блок всегда придерживается её, + ко всему - overflow со значением scroll.
Отсебятина: также очень полезное свойство, много раз видел подобное на различных сайтах (обычно такое делают для тех, кто
смотрит на сайт со своего телефона).

А дальше следующее значение - auto!
Оно само определяет, когда нужен скролл (горизонтальный/вертикальный - нет разницы) а когда нет. 
*/

.example-block {
	overflow: auto;
}

/*
БЫСТРО ЗАХОДИМ В БРАУЗЕР И СМОТРИМ, А ТАМ... А ТАМ!!...
а там скролл вертикальный появился!
Это правильное решение, т.к по ширине всё и так нормально, а вот с высотой немного загиб - поэтому здесь
нужен именно вертикальный скролл, никак не горизонтальный.

Последнее свойство (наконец-то!!!) - display!
"Многоцелевое свойство, которое определяет, как элемент должен быть показан на странице." - © Жека
Ну, Жека уже всё объяснил в нескольких словах, так еще и очень просто.. а мое дело дополнить всё это
более.. "подробным" объяснением.
Если вкратце - это свойство отвечает за отображение элементов на странице И НЕ ТОЛЬКО.
По быстрому забегая вперед скажу, что с этим свойством мы можем делать так, чтобы элемент ИСЧЕЗ со страницы,
или чтобы блочный элемент стал СТРОЧНЫМ.. или наоборот - чтобы строчный элемент стал блочным.

Первое значение свойства display - block.
Давайте сразу же применим его к нашему блоку и зайдем в браузер:
*/

.example-block {
	overflow: visible; /* обнуляшки!! */
	height: auto; /* обнуляшки!! */
	min-height: auto; /* обнуляшки!! */
	max-height: none; /* обнуляшки!! */
	display: block;
}

/*
Применив его к блоку никаких изменений мы не увидим - элемент то сам по себе блочный, а мы его
"еще раз сделали блочным". Но если применить его к строчному тегу - мы сможем применять к нему свойства padding,
margin, width & height и т.д!
Всё дело в том, что это свойство меняет отображение элемента на странице, делая его блочным и применяя к нему
все свойства блочного элемента.. короче - всё просто!
А тем временем мы просто применим свойства для блочных элементов к строчному тегу и зайдем в браузер: 
*/

.example-string {
	margin: 0; /* обнуляшки!! (я когда-то прописывал это свойство но оно не применялось, а теперь применяется!) */
	padding: 20px;
	border: 1px solid #000000;
}

/*
Заходя в браузер мы видим.. свастику :D
А если серьезно - ошибки в работе padding и border в силу того, что эти свойства - не для строчных тегов.
Это можно исправить, добавив свойство display со значением block! это то мы сейчас и сделаем:
*/

.example-string {
	display: block;
}

/*
Зашли в браузер, посмотрели - о чудо, свойства применились!!
Теперь строчный элемент будет отображаться точно также как и его "старший брат" - то бишь example-block.

Следующее, не мало важное значение свойства - inline. Оно полностью противоположно значению block,
т.е - делает элемент не блочным, а наоборот - строчным. Блочный элемент начинает вести себя также, как и строчный - начинает
занимать ширину равную контенту, выстраивается в 1 ряд со всеми строчными элементами, не реагирует на свойства для блочных тегов.
Сейчас мы это и проверим! -
*/

.example-block {
	padding: 20px;
	border: 1px solid #000000;
	display: inline;
}

/*
Зашли в браузер - какая-то каша, опять!
Всё потому что наш див стал СТРОЧНЫМ элементом, а не блочным.

Следующее значение свойства display - inline-block.
Оно уникально! благодаря нему, элемент становится строчным - также занимает ширину равную контенту, выстраивается
в ряд (в строку), но на нем работают те же свойства, что и для блочных! Т.е - маргины, паддинги и т.д.
Проверим это! -
*/

.example-block {
	padding: 0; /* обнулишяки!! */
	display: block; /* обнуляшки!! */
}

.example-string {
	width: auto; /* обнуляшки!! */
	display: inline-block;
}

/*
Зашли в браузер и видим такую картину: элемент принял форму блока (из-за паддингов), на нём сработал бордер, он всё
также занимает ширину равную контенту и он не спрыгнул со своего места! Он всё также "висит" на одной строке, в ряду.
А что если и ширину добавить? сработает или нет? а мы это проверим! 
*/

.example-string {
	width: 500px;
}

/*
Посмотрели в браузере - работает!
Как по мне, это лучшее значение у свойства display - элемент становится блочно-строчным и может принимать свойства
как для блочных элементов, так и для строчных. Вообщем - это своего рода гибрид между блочным элементом и строчным.

А дальше мы идем к последнему, чуть ли не самому важному значению - none.
Оно полностью убирает блок со страницы, при этом ширина блока не резервируется (не занимается другими блоками/строчными
элементами).
Посмотрим что произойдет, если мы применим свойство display с этим значением к блоку -
*/

.example-block {
	display: none;
}

/*
Снова заходим в браузер и смотрим - а там у нас блок пропал! а точнее первый блок - у нас то их целых два :)
Блочно-строчный элемент занял место первого блока, а первого и след простыл.
Его просто "не существует" - его нет и не будет на странице, а место которое он занимал - передается другому
элементу (в нашем случае - нижнему блоку, а он единственный на странице).

На этом всё! домашнее задание из урока - в папке "Домашка" :)
*/

/* --------------------------------------------------------------------------------------------------------------------------- */

/* Последние штрихи */


.example-block {
	display: block;
	margin: 0px 0px 30px 0px;
}

.example-string {
	display: inline;
	border: 0;
	padding: 0;
}

/*
Теперь точно всё - никаких br'ов :)
*/