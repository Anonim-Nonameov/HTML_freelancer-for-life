/* Урок №4 - CSS позиционирование. */

/*
Сегодня мы поговорим о позиционировании! позиционирование очень часто используется при верстке
современных макетов: это и различные выпадающие меню, и всплывающие окна (так называемые поп-апы),
это и "липкий" хедер который следует за нами при скролле, и всяческое нестандартное расположение
элементов на странице. Но пользоваться всеми этими крутыми возможностями нужно очень грамотно -
этому мы в скором времени и научимся! но сначала мы немного стилизуем наш index.html файлик, чтобы
он не казался таким "сероватым":
*/

body {
    padding: 30px;
    font-family: "Arial", Helvetica, sans-serif;
}

.block {
    border: 5px solid red;
    max-width: 800px;
    height: 800px;
    margin: 0px auto;
}

.block div {
    font-size: 18px;
    font-weight: bold;
    line-height: 50px;
    text-align: center;
}

.block__1 {
    background-color: #ece89d;
}
.block__2 {
    color: #fff;
    background-color: #5e5373;
}
.block__3 {
    background-color: #18b5a4;
}

/*
Итак, начнем! первое, основное свойство позиционирования так и называется - position, а его
значение по умолчанию - static. Вообще, свойство position устанавливает ТИП позиционирования
элемента относительно других элементов, либо окна браузера. При значении по умолчанию (static),
все наши блоки будут выводиться как обычно, на них не будет дополнительных свойств. То есть,
position: static; указано уже заранее У ВСЕХ элементов на странице, а это значит, что дублировать
его не надо. А мы идем дальше!

Следующее значение свойства position - relative. Положение у элемента устанавливается ОТНОСИТЕЛЬНО
(запомните это слово) его начального положения. Что это значит? сейчас узнаем! - свойство position
со значением relative может использоваться дополнительно с новыми свойствами позиционирования,
которые становятся доступными после того, как мы сменили значение position'а с "по умол." на
любое другое (ну вот relative, например):

left, top, right, bottom


Используя свойство position со значением relative и доп. свойства позиционирования (left, top и т.д)
мы можем сдвигать наш элемент либо по гориз., либо по верт. ОТНОСИТЕЛЬНО его текущего положения.
Например, наш второй блок. Я хочу сдвинуть его слева на 50px и от верха на 60px:

*/

.block__2 {
    position: relative;
    left: 50px;
    top: 60px;
}

/*
Заходим в браузер, смотрим - сразу становится видно, что наш блок-2 сдвинулся относительно своего
изначального положения. Вместо себя он оставил пустое место, размером которое он занимал ДО того,
как его "заставили" подвинуться (:D). С остальными блоками ничего не произошло, как стояли на
своих местах так и стоят, никто и ничто им не мешало и не мешает. Правда, есть одно но - блок-3
был "накрыт" блоком-2 ввиду того, что последний сдвинулся. Бывает всякое в жизни, такое тоже :)
Еще следует отметить, что НЕЛЬЗЯ использовать свойства left и right одновременно, произойдет..
ну, диссонанс так сказать. А ведь логично - как сдвинуть элемент сразу и справа и слева? так
не правильно и делать так не стоит, абсолютно. А мы продолжаем. Вместе с position: relative; мы
можем использовать еще одно доп. свойство - z-index. Значениями z-index'а могут быть числа, но
по умолчанию оно равно нулю. И включается он, то есть начинает работать, только тогда, когда у
свойства position значение равно relative или любое другое значение, да - есть значения помимо
relative и мы их скоро изучим. z-index отвечает за контроль положения элементов, которые так
или иначе запозиционированны. Звучит сложно, но на деле проще простого! например, в данный момент
блок-2 перекрывает блок-3, но если я к блоку-3 применю position со значением relative а также
укажу z-index больший чем у блока-2 (а у него он по умолчанию, то есть 0), то случится кое что
очень даже интересное 
*/

.block__3 {
    position: relative;
    z-index: 2;
}

/*
Переходим в браузер и смотрим -  блок-3 "накрыл" блок-2, теперь он "главный" :)
Но что если мы изменим ход битвы, повысив z-index у второго блока?
*/

.block__2 {
    position: relative;
    z-index: 3;
}

/*
Опять заходим в браузер - всё вернулось на круги своя! блок-2 вновь стал "главнее" и перекрыл
блок-3. z-index тоже очень часто используется в верстке: вспоминаем те же поп-апы, выпадающие
меню и так далее, где надо чтобы меню выпало поверх каких-то блоков. Тут же и вступает в игру
это прекрасное свойство - z-index! а мы идем дальше - значение свойства position, absolute. 

Значение position'а absolute.. о да, очень трудное на понимание значение. Простыми словами,
блок, к которому применено абсолютное позиционирование, как будто "вырывается из потока",
грубо говоря "из HTML-кода". Он словно зависает в воздухе, он перестает иметь какие-то
физические размеры. Сейчас мы посмотрим на него в деле! его обязательно должно сопровождать
хоть какое-то свойство из свойств позиционирования: top, right, center или bottom, так как
разные браузер могут по разному реагировать на position со значением absolute. И так, например,
я хочу разместить свой блок-2 в верхнем левом углу:
*/

.block__2 {
    position: static; /* обнуляшки!! */
    z-index: 0; /* обнуляшки!! */
}

.block__3 {
    position: static; /* обнуляшки!! */
    z-index: 0; /* обнуляшки!! */
}

.block__2 {
    position: absolute;
    top: 0;
    left: 0;
}

/*
Зашли в браузер и смотрим: блок-2 улетел куда-то в угол, и мало того что он улетел: он был лишен
своей ширины, а мы знаем, что каждый блочный элемент имеет ширину в 100%. Он начал вести себя как
строчный элемент - его ширина стала равна ширине контента, и он прилип к левому верхнему углу нашего
браузера. Почему к левому верхнему? потому что мы указали top: 0 и left: 0, то есть сверху и слева
он будет сдвинут ни на сколько, поэтому то он и приклеился к углу. И кстати - можно увидеть, что
на том месте, где раньше стоял этот блок-2 стоит блок-3. А я уже говорил, что элемент, к которому
применено свойство position со значением absolute "ВЫРЫВАЕТСЯ" из HTML-кода, и поэтому блок-2 завис
где-то в воздухе, там где мы его запозиционировали дополнительными свойствами по вертикали а также
горизонтали. И то пространство, которое он занимал между блоками 1 и 3 исчезло, поэтому блок-3
как-бы занял его место. Блок-2 выдернулся, и всё, что было снизу, поднялось по коду.

Но в чём вообще прикол абсолютного позиционирования и как сделать так, чтобы можно было абсолютный
элемент позиционировать относительно другого элемента? - как раз абсолютным позиционированием
и строятся большинство элементов, это и выпадающие меню, и поп-апы и так далее. Но работает оно
хорошо и классно только тогда, когда мы можем его (абсолютный элемент) позиционировать относительно
его родителя. И для того, чтобы мы могли позиционировать наш блок-2 относительно родителя, а у нас
это элемент с классом .block (элемент с огромной красной рамкой, в котором как раз и хранятся наши
блоки), нужно добавить этому родительскому блоку свойство position со значением relative:
*/

.block {
    position: relative;
}

/*
Посмотрели в браузере на результат и увидели, что блок-2 действительно прижался к углу нашего
основного блока. При этом не перестал быть "абсолютным" элементом. У него всё также нету никаких
физических размеров, высоты например. Но почему он выравнивается абсолютно относительно родителя
только тогда, когда мы задали родителю position со свойством relative? до того момента, когда мы
задаем родительскому элементу position со значением relative, "отсчет" позиционирования или же
"стартовая позиция" исходит от тега body. А когда родительский блок относительно запозиционирован,
отсчет идёт уже непосредственно от него, а не от body. И вот, теперь когда мы можем абсолютно
запозиционированный элемент выравнивать относительно того, чего хотим, это дает нам некоторую..
ну, "гибкость" так сказать. Позиционируйте, в общем, как хотите! но что делать с размерами такого
элемента, он же как-бы "схлопнулся"? ответ прост - задайте размеры непосредственно самому элементу!
так как блочный элемент перестает быть блоком, он как-бы "схлопывается" и теряет все свои качества.
Вот вам пример с заданием ширины непосредственно блоку, для наглядности так сказать: 
*/

.block__2 {
    width: 100%;
}

/*
Заходим в браузер и смотрим - всё получилось, блок-2 растянулся и "затмил" собой блок-1.
Но и это еще не всё - если даже блок-2 и потерял все свои размеры, то это еще не значит, что мы не
сможем с ним как-то да взаимодействовать. Например, мы можем его двигать! -
*/

.block__2 {
    top: 20px;
    left: 30px;
}

/*
Заходим в браузер и лишний раз убеждаемся в том, что позиционировать элементы на странице можно как
угодно - блок сдвинулся! но мы можем его двигать еще двумя оставшимися свойствами, а именно свойство
right и свойство bottom, а также обнулим свойства top и left:
*/

.block__2 {
    top: auto; /* обнуляшки! */
    left: auto; /* обнуляшки! */

    bottom: 20px;
    right: 30px;
}

/*
Еще раз заходим в браузер и видим, что top и left сработали (мы установили им значения по умолчанию),
как и свойства bottom и right - блок сдвинулся справа на 30 пикселей и снизу на 20 пикселей, то есть
на указанное нами значение. И точно также, как и в случае со свойством position и его значением
relative, на абсолютно спозиционированный элементе будет работать свойство z-index. Для демонстрации
я вновь верну блок-2 наверх и "закрою" им другие блоки, затем блоку-3 задам position со значением
relative, а также больший z-index:
*/

.block__2 {
    bottom: auto; /* обнуляшки!! */
    right: auto; /* обнуляшки!! */

    top: 20px;
    left: 30px;
}

.block__3 {
    position: relative;
    z-index: 2;
}

/*
Итак.. зайдя в браузер мы увидим, что блок-3 закрыл собой блок-2, который в свою очередь закрывает
блок-1. Так произошло потому, что у блока-3 z-index намного больше чем у блока-2, у которого он
вообще равен нулю. Получилось что-то вроде кривой лесенки :D И то же самое будет, если я задам
блоку-1 больший z-index, чем у блока-2:
*/

.block__1 {
    position: relative;
    z-index: 2;
}

/*
Ну вот. Таким образом, от блока-2 осталась лишь его маааленькая часть, которую еще как-то да видно.
А теперь я обнулю вообще ВСЁ, т.е всякие там position'ы, z-index'ы, top'ы и left'ы для демонстрации
следующего значения свойства position:
*/

.block__1,
.block__2,
.block__3 {
    width: auto; /* обнуляшки!! */
    position: static; /* обнуляшки!! */
    top: auto; /* обнуляшки!! */
    left: auto; /* обнуляшки!! */
    z-index: 0; /* обнуляшки!! */
}

/*
Ну вот и всё, мы вернули всё на круги своя - блок-1 на самом верху, блок-2 под ним, а блок-3 под
блоком-2. А мы идем дальше, значение свойства position - fixed!

Очень интересное значение свойства position, fixed. Оно также как и position: absolute вырывает
элемент из потока, но он (элемент) "крепится", "фиксируется" сугубо по окну браузера. То есть, мы
видим что нашему родительскому элементу задан position со свойством relative, соответственно когда
мы применяли absolute к какому нибудь элементу, мы могли запозиционировать его относительно родителя,
то сейчас указав также fixed с некими другими свойствами, он всё равно будет прикреплён к окну:
*/

.block__2 {
    position: fixed;
    top: 0;
    left: 0;
}

/*
Зайдя в браузер, мы видим, что элемент всё равно закреплён относительно окна браузера, не смотря
на то, что родительскому элементу задан position со значением relative. И помимо всего этого,
элемент "фиксируется" на этом месте. Что значит "фиксируется?" я покажу вам на примере, для этого
я задам родительскому блоку высоту в 1500px, чтобы появился скролл и мы могли скроллить страницу:
*/

.block {
    height: 1500px;
}

/*
Чуть проскроллив страницу можно понять, что как бы мы не пытались "уехать" от этого элемента, он
всё также остается на своем месте и сходить оттуда НЕ НАМЕРЕН. Он буквально зафиксирован в этом
месте и убрать его оттуда невозможно даже проскроллив страницу вниз. Благодаря свойству position
со значением fixed мы можем создавать меню на страницах - вы наверняка видели на каком нибудь
сайте меню, которое буквально "преследует" нас при скролле, так вот, с position: fixed; и немного
JavaScript'а мы можем делать точно такие же меню! но всё это - в будущем и, надеюсь, ближайшем.
И да - вы наверняка заметили, что благдаря position: fixed наш блок опять "схлопнулся", как и в
случае с position: absolute? он опять потерял все свои физические размеры и не имеет ни ширины, ни высоты. Это можно легко исправить, добавив размеры непосредственно блоку: 
*/

.block__2 {
    width: 100%;
}

/*
Ну вот, теперь наш блок вновь занимает 100% ширины окна браузера. А теперь про position: fixed и z-index. Свойство z-index работает с position: fixed также, как и с любыми другими значениями свойства position (relative/absolute):
*/

.block__3 {
    position: relative;
    z-index: 2;
}

/*
Заходим браузер (да, очень люблю эту фразу) и смотрим: начинаем скроллить, и когда доходим до блока-3, происходит интересный эффект - мы его уже вот-вот обходим, но он "перепрыгивает" наш блок-2, но тем не менее страницу это не ломает, мы можем скроллить и всё будет хорошо.
А мы идем дальше, последнее значение свойства position - sticky!

sticky - очень интересное значение свойства position, а дословно переводится оно как "липкий". 
Применяя этот параметр, мы наделяем наш блок таким гибридным значением - это что-то вроде смеси position: static и position: fixed. Указав блоку position: sticky и дополнительное свойство top со значением 0, наш блок превратится из static в fixed тогда, когда верхняя граница браузера достигнет его, его положения. Сложно? нет, ни капли! особенно, если посмотреть на пример: 
*/

.block__2 {
    width: auto; /* обнуляшки!! */
    position: static; /* обнуляшки!! */
}

.block__3 {
    position: static; /* обнуляшки!! */
    z-index: 0; /* обнуляшки!! */
}

.block__2 {
    position: sticky;
    top: 0;
}

/*
Зайдя в браузер ничего интересного мы не увидим - всё вернется к дефолтному состоянию, но стоит нам только
проскроллить страницу так, чтобы верхняя часть окна браузера достигла блока, так после этого блок прилипает к
самой верхней части окна браузера и не отходит от неё, как бы мы не скроллили страницу. Именно в этот момент
блок и переходит в состояние position: fixed. Но когда у нас стоит position со значением fixed, наш блок выровнен
относительно окна браузера, а при position: sticky он всегда будет стоять относительно своего истинного родителя.
То есть указав свойство position со значением sticky, его родитель сразу становится "коробкой" для этого элемента.

На первый взгляд это очень полезное свойство (и оно так и есть, все свойства по-своему полезны), и один раз
посмотрев на это свойство можно сделать вывод, что именно его используют для создания липкого меню, но на самом
деле можно использовать оба значения этого свойства для создания подобных меню. Но Жека в этом уроке говорил, что
position: sticky используется верстальщиками редко в силу того, что он не так хорошо поддерживается браузерами,
а кроссбраузерность очень важна! но на дворе декабрь 2021-го года, и скорее всего он будет поддерживаться не так
уж и плохо!

А мы на этом всё! задание находится в папке "Задания" :)
*/