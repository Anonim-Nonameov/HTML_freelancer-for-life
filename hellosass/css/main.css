/* Урок №5 - препроцессоры Sass & SCSS. */

/*
В предыдущих уроках мы познакомились с осни HTML и CSS, поэтому нам следует переходить на
НOВЫЙ УРОВЕНЬ! сегодня мы поговорим о мощном препроцессоре Sass, и начинаем мы уже сейчас!

Sass - это в первую очередь препроцессор для CSS, он значительно расширяет возможности
стандартных таблиц стилей, делает работу более быстрой и приятной. В этом уроке мы
познакомимся с такими крутыми возможностями как переменные, миксины, шаблоны, вло-
-женность и другими крутышками! Однако работать мы будем вовсе не здесь - работать
мы будем с файлом main.scss, и тут у вас может возникнуть один резонный вопрос -
почему ".scss", а не ".sass"? об этом позже, а пока что мы поговорим о проблеме с
препроцессором. Поскольку сами по себе файлы scss либо sass браузеры непонятны (а
они действительно ему непонятны), то он просто не сможет их прочитать. Нам предстоит
ПЕРЕКОДИРОВАТЬ файлы scss в файлы понятные браузеру, то есть в CSS! для этого чаще
всего используется программа Prepros, которая компилирует файлы scss в CSS. Настроив
её, наш scss код будет перекомпилироваться в отдельный css файл, который я уже создал,
и называется он style.css! То есть - мы пишем код на scss, а он у нас по быстренькому
преобразуется в CSS. Всё гениальное просто :) Начнем с синтаксиса SASS.

Синтаксис оригинального SASS отличается от привычной записи CSS: тут нет фигурных скобок,
нет точки с запятой после параметра, каждый параметр начинается с новой строки и ОЧЕНЬ
сильно важны отступы. Вот вам табличка с тем, как выглядят три записи в SASS и CSS:

------------------------------------------------------------------------------------------

SASS:

nav
	ul
		margin: 0
		padding: 0
		list-syle: none

	li
		display:  inline-block

	a
	 	display:  block
	 	padding: 6px 12px
	 	text-decoration:  none

------------------------------------------------------------------------------------

CSS:

nav ul {
	list-style: none;
	padding:  0;
	margin:  0;
}

nav li {
	display: inline-block;
}

nav a {
	display: block;
	text-decoration:  none;
	padding: 6px 12px;
}

------------------------------------------------------------------------------------

Вот! как вы видите, здесь разница есть и она ОЧЕНЬ большая. Нет абсолютно никаких
скобок, нет точки с запятой, и именно из-за этого был придуман синтаксис SCSS, в
котором во многом возвращается ПРЕЖНИЙ вид CSS:

SCCS:

nav {
	ul {
		list-style: none;
		padding:  0;
		margin:  0;
	}


	li {
	display: inline-block;
	}

	a {
		display: block;
		text-decoration:  none;
		padding: 6px 12px;
	}
}

------------------------------------------------------------------------------------

В SCSS возвращается привычный для нас синтаксис CSS, поэтому работать с ним в разы
легче, чем с SASS. А теперь напишем что нибудь в main.scss! первым делом я стилизую
див с классом block внутри main.scss (так мой код будет выглядеть в формате CSS):
*/

.block {
	font-size: 50px;
	line-height: 60px;
	padding: 30px;
}

/*
Пока что никакой разницы между SCSS и CSS не наблюдается, поэтому пришла пора показать
первую суперспособность SCSS.

СУПЕРСИЛА №1 - Вложенность

С приходом SCSS, к нам также пришло понятие вложенности. Что это такое? вложенность -
это суперспособность SCSS внезавимисомти от синтаксиса, работаем мы с SCSS или с Sass,
ПИСАТЬ ПРАВИЛА ВНУТРИ ДРУГИХ ПРАВИЛ! но о чем идет речь? допустим, что у нас в элементе
с классом block есть какой-то текст, и его отрывок помещен в span. Я хочу выделить это
слово, сделав его.. ну зеленым, например. Так вот, используя такую суперспособность SCSS
как вкладываемость правил или просто вложенность, я могу после последнего параметра (а
это у нас line-height: 20px) написать слово span и открыть фигурные скобки прямо внутри
уже существуюжего набора правил! внутри я ему могу написать свойство color со значением
green, как мы и хотели (так будет выглядеть код в синтаксисе SCSS):

.block {
	font-size: 50px;
	line-height: 60px;
	padding: 30px;
	span {
		color: green;
	}
}

Готово! таким образом, страница моментально преобразится, а span станет зеленого цвета!
Но как это будет работать, если браузер просто-напросто НЕ ПОНИМАЕТ синтаксиса SCSS?
всё просто - программа Prepros (которой у вас, возможно, нет) компилирует мой SCSS
код в CSS, создавая определенные правила. Вот что находится в style.css на данный момент:
*/

.block {
  font-size: 50px;
  line-height: 60px;
  padding: 30px;
}
.block span {
  color: green;
}

/*
Как мы видим, в style.css появилась точная копия моего SCSS кода, но скомпилированная на
свой лад. У нас в style.css есть определенные стили как для элемента с классом "block", так
и для элемента span внутри элемента с тем же классом "block". Если подумать, то мы же ведь 
дублируем род. класс! то есть, мы сначала пишем ".block", затем уже пишем span и описываем
его стили.  В препроцессоре SCSS такого нет - стили элемента и его дочерних элементов укладываются 
в  одно правило, что делает код более читабельным и изящным. Сразу становится понятно, что
span находится внутри div'а с классом "block", ибо он физически прописан В правиле для
элемента с классом "block". Но на этом вложенность Sass далеко не ограничивается. На данный
момент у нас более усложненная версия index.html, где внутри div'а с классом "block" добавился
второй div с классом "block__text". Изменим стили для div'а с классом "block__text", изменив
его размер текста на 80 пикселей в файле main.scss:

.block {
	...
	.block__text {
		font-size: 80px;
	}
}

Идеально! но как же будет выглядеть этот код в формате CSS? а вот так:
*/

.block {
	font-size: 50px;
	line-height: 60px;
	padding: 30px;
}

.block span {
	color: green;
}

.block .block__text {
	font-size: 80px;
}

/*
Сразу видно, что кода в таком формате становится много. На несколько строк больше, чем в
синтаксисе SCSS. Но код сработает в любом случае, и размер шрифта в div'е сильно увеличится.
Кроме того, вложенность span'а всё также продолжает работать, ибо мы обратились ко ВСЕМ тегам
span, что находятся в div'е с классом "block", и не важно, стоит ли правило для span раньше
чем правило для div'а с классом "block__text" или позже него:

Можно так:

.block {
	...
	span {
		...
	}

	.block__text {
		...
	}
}

А можно так:

.block {
	...
	.block__text {
		...
		span {
			...
		}
	}
}

Я заменю код в main.scss на тот, в котором span хранится ВНУТРИ правила для div'а с классом
block__text, потому что так будет правильней, ведь span физически хранится внутри div'а.
Идем дальше! - ко вложенности Sass применимы всё те же операторы, что и применимы для CSS,
а также новые операторы. Вы спросите: "о чем идет речь, молодой человЭк?", а я вам отвечу,
что допустим у нас в index.html есть два параграфа с текстами - "Параграф №1" и "Параграф
№2" соответственно. И я хочу украсить эти параграфы. Добавим следующие стили в main.scss:

.block {
	...
	p {
		color: red;
	}
	...
}

Добавив строку p {color: red;}, ВСЕ параграфы на нашей странице станут красными. Но вдруг
мне резко захотелось изменить цвет на красный только у первого параграфа, чтобы только он
был красным. Как же мне этого добиться? очень просто! в CSS у нас, если вы помните, был
селектор вложенности, который выбирал элементы первого уровня (те, что идут сразу в самом
элементе) - знак больше (>). Чтобы выбрать параграф первого уровня, мы должны были прописать
что-то вроде следующего:
*/

.block > p {
	color: red;
}

/*
Этот код сработает одновременно и в CSS, и в SCSS, но мы же ведь знаем, что длинный код =
плохой код! мы можем его сократить следующим образом:

.block {
	...
	>p {
		color: red;
	}
	...
}

Заходим в браузер после добавления такого кода и... УРА! - цвет первого параграфа изменен!
То есть мы просто берём и прописываем	оператор, а после него ставим селектор типа, класса или
любой другой. После работы этого кода, первый параграф окрасится в красный цвет, а второй - не
окрасится, потому что он находится на другом уровне вложенности. Идём дальше!

Есть и множество других операторов, которые очень редко используются и говорить о них мы по этой
причине не будем, но поговорим мы о НОВОМ интересном операторе, который ускорит нашу работу В РАЗЫ.
Это оператор and (&). Простая заковырина, которая обозначает слово and (и). Как она применяется?
Ну как сказать.. если говорить простым языком, то Sass (без разницы, в синтаксисе SCSS или нет)
заменяет значок and, амперсанд (эта закорючка так и называется) на родителя, если говорить про
наш случай, то обозначать он будет ".block". Допустим, что у нас есть в index.html ссылка c классом 
link, ведущая на какой нибудь сайт, гугл например. Я хочу сделать её синей и добавить ей нижнее 
подчеркивание, не вписывая правило в одно общее, где родитель div с классом "block" - вместо этого
я создам новое правило, специально для ссылки и закомменитирую параграфы в index.html и стили для
них в main.scss, ибо они мне уже не нужны:
*/

.link {
	color: blue;
	text-decoration: underline;
}

/*
A.S: В принципе, в SCSS будет написано то же самое, так что записывать то, как это будет выглядить
в синтаксисе SCSS - смысла нет.

Далее, я хочу изменить её цвет (ссылки) на какой нибудь другой, НО только при наведении на неё!
В CSS мы бы сделали это следующим образом: 
*/

.link:hover {
	color: green;
}

/*
Такая запись сработает как в CSS, так и в SCSS, но мы же ведь можем укоротить её используя оператор
and (&)! напишем следующее в main.scss:

.link {
	&:hover {
		color: green;
	}
}

После этого, в style.css появляется следующая строчка в конце: ".link:hover {...}", что означает,
что наш амперсанд (оператор "и") превратился в слово link, а link - родительский элемент, ссылка.
Заходим в браузер - меняется цвет ссылки при наведении! причем тот же самый фокус сработает и с
любым другим псевдо-классом/псевдо-элементом, писать их мы можем ВНУТРИ родительского правила и
просто ставить оператор "и", ничего сложного! повторяю: оператор амперсанд просто берет и ищет
название родителя, и после того как его найдет - вставляет вместо себя. Но этот оператор можно
использовать еще тогда, когда у нас несколько классов для одного тега. Например, у нашего div'а
с класом "block" есть другой класс, "parent--block". Внутри правила для элемента с классом .block
в нашем .main.scss мы ставим оператор амперсанд и после него прописываем точку, а уже после точки
класс "parent--block", применяя к нему какие-то свойства:

.block {
	...
	&.parent--block {
		font-size: 55px;
	}
}

Таким образом, размер ссылки на нашей странице будет увеличен с 50-ти пикселей на 55 пикселей. А
вот в нашем style.css файле в это время появился следующий кусок кода:
*/

.block.parent--block {
	font-size: 55px;
}

/*
Как мы видим, в файле style.css появился селектор двух классов. И кстати, приоритетность такого
селектор не увеличивается этой записью - мы просто берем и указываем, что к элементу с классами
"block" и "parent--block" применяются следующие такие-то да такие-то стили, и всё, не более того!
И еще один интересный пример использования оператора амперсанд: представим, что у нас на странице
есть ещё одна ссылка, которая находится ВНЕ элемента с классом "block" и ведет она на сайт youtube,
но помимо всего этого, размеры ссылок стали равными - 25 пикселей у каждой ссылки, а также они 
поменялись местами - ссылка ведущая на youtube находится В div'е с классом "block", а ссылка на
сайт гугла находится ВНЕ div'а. Я хочу, чтобы ссылка, которая находится в div'е изменила свой размер
с 25-ти пикселей на 35, став больше той, что находится вне, и кроме того - уж ссылка ведет на ютуб,
то при hover'е её цвет должен быть красным - ютуб, как  никак. Вы скажете: "а ты просто пропиши
внутри правила для элемента div с классом «block» правило для элемента с классом «link» и поменяй
его размер там же, после этого внутри уже правила для «link» добавь специальный :hover, используя
оператор амперсанд" - и вы будете абсолютно правы, если так скажате! это будет самым верным решением
задачи, но что, если нам хочется по другому? например, изменить стили в правиле для ссылки с классом
"link"? в таком случае, мы можем сделать вот так:

.link {
	...
	.block & {
		font-size: 35px;
		&:hover {
			color: red;
		}
	}
*/

/*
Готово, заходим в браузер, смотрим: размер первой ссылки стал больше, а теперь наводим мышкой на
неё - цвет изменился на красный, всё получилось! но что значит наша запись? сейчас я покажу вам,
что появилось в файле style.css после этого кода:
*/

.block .link {
  font-size: 35px;
}
.block .link:hover {
  color: red;
}

/*
Вот и всё, ничего интересного. Мы просто обращаемся к ссылке внутри div'а.block и меняем её размер
на такой-то, а после этого меняем её цвет при hover'е на красный. Также, вместо амперсандов у нас 
подставляется название текущего родителя, в нашем случае это "link".

На этом всё, остальное - позже!) (конспект получился маленьким, извиняюсь!)
*/