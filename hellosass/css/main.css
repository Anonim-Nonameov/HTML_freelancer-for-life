/* Урок №5 - препроцессоры Sass & SCSS. */

/*
В предыдущих уроках мы познакомились с осни HTML и CSS, поэтому нам следует переходить на
НOВЫЙ УРОВЕНЬ! сегодня мы поговорим о мощном препроцессоре Sass, и начинаем мы уже сейчас!

Sass - это в первую очередь препроцессор для CSS, он значительно расширяет возможности
стандартных таблиц стилей, делает работу более быстрой и приятной. В этом уроке мы
познакомимся с такими крутыми возможностями как переменные, миксины, шаблоны, вло-
-женность и другими крутышками! Однако работать мы будем вовсе не здесь - работать
мы будем с файлом main.scss, и тут у вас может возникнуть один резонный вопрос -
почему ".scss", а не ".sass"? об этом позже, а пока что мы поговорим о проблеме с
препроцессором. Поскольку сами по себе файлы scss либо sass браузеры непонятны (а
они действительно ему непонятны), то он просто не сможет их прочитать. Нам предстоит
ПЕРЕКОДИРОВАТЬ файлы scss в файлы понятные браузеру, то есть в CSS! для этого чаще
всего используется программа Prepros, которая компилирует файлы scss в CSS. Настроив
её, наш scss код будет перекомпилироваться в отдельный css файл, который я уже создал,
и называется он style.css! То есть - мы пишем код на scss, а он у нас по быстренькому
преобразуется в CSS. Всё гениальное просто :) Начнем с синтаксиса SASS.

Синтаксис оригинального SASS отличается от привычной записи CSS: тут нет фигурных скобок,
нет точки с запятой после параметра, каждый параметр начинается с новой строки и ОЧЕНЬ
сильно важны отступы. Вот вам табличка с тем, как выглядят три записи в SASS и CSS:

------------------------------------------------------------------------------------------

SASS:

nav
	ul
		margin: 0
		padding: 0
		list-syle: none

	li
		display:  inline-block

	a
	 	display:  block
	 	padding: 6px 12px
	 	text-decoration:  none

------------------------------------------------------------------------------------

CSS:

nav ul {
	list-style: none;
	padding:  0;
	margin:  0;
}

nav li {
	display: inline-block;
}

nav a {
	display: block;
	text-decoration:  none;
	padding: 6px 12px;
}

------------------------------------------------------------------------------------

Вот! как вы видите, здесь разница есть и она ОЧЕНЬ большая. Нет абсолютно никаких
скобок, нет точки с запятой, и именно из-за этого был придуман синтаксис SCSS, в
котором во многом возвращается ПРЕЖНИЙ вид CSS:

SCCS:

nav {
	ul {
		list-style: none;
		padding:  0;
		margin:  0;
	}


	li {
	display: inline-block;
	}

	a {
		display: block;
		text-decoration:  none;
		padding: 6px 12px;
	}
}

------------------------------------------------------------------------------------

В SCSS возвращается привычный для нас синтаксис CSS, поэтому работать с ним в разы
легче, чем с SASS. А теперь напишем что нибудь в main.scss! первым делом я стилизую
див с классом block внутри main.scss (так мой код будет выглядеть в формате CSS):
*/

.block {
	font-size: 50px;
	line-height: 60px;
	padding: 30px;
}

/*
Пока что никакой разницы между SCSS и CSS не наблюдается, поэтому пришла пора показать
первую суперспособность SCSS.

СУПЕРСИЛА №1 - Вложенность

С приходом SCSS, к нам также пришло понятие вложенности. Что это такое? вложенность -
это суперспособность SCSS внезавимисомти от синтаксиса, работаем мы с SCSS или с Sass,
ПИСАТЬ ПРАВИЛА ВНУТРИ ДРУГИХ ПРАВИЛ! но о чем идет речь? допустим, что у нас в элементе
с классом block есть какой-то текст, и его отрывок помещен в span. Я хочу выделить это
слово, сделав его.. ну зеленым, например. Так вот, используя такую суперспособность SCSS
как вкладываемость правил или просто вложенность, я могу после последнего параметра (а
это у нас line-height: 20px) написать слово span и открыть фигурные скобки прямо внутри
уже существуюжего набора правил! внутри я ему могу написать свойство color со значением
green, как мы и хотели (так будет выглядеть код в синтаксисе SCSS):

.block {
	font-size: 50px;
	line-height: 60px;
	padding: 30px;
	span {
		color: green;
	}
}

Готово! таким образом, страница моментально преобразится, а span станет зеленого цвета!
Но как это будет работать, если браузер просто-напросто НЕ ПОНИМАЕТ синтаксиса SCSS?
всё просто - программа Prepros (которой у вас, возможно, нет) компилирует мой SCSS
код в CSS, создавая определенные правила. Вот что находится в style.css на данный момент:
*/

.block {
  font-size: 50px;
  line-height: 60px;
  padding: 30px;
}
.block span {
  color: green;
}

/*
Как мы видим, в style.css появилась точная копия моего SCSS кода, но скомпилированная на
свой лад. У нас в style.css есть определенные стили как для элемента с классом "block", так
и для элемента span внутри элемента с тем же классом "block". Если подумать, то мы же ведь 
дублируем род. класс! то есть, мы сначала пишем ".block", затем уже пишем span и описываем
его стили.  В препроцессоре SCSS такого нет - стили элемента и его дочерних элементов укладываются 
в  одно правило, что делает код более читабельным и изящным. Сразу становится понятно, что
span находится внутри div'а с классом "block", ибо он физически прописан В правиле для
элемента с классом "block". Но на этом вложенность Sass далеко не ограничивается. На данный
момент у нас более усложненная версия index.html, где внутри div'а с классом "block" добавился
второй div с классом "block__text". Изменим стили для div'а с классом "block__text", изменив
его размер текста на 80 пикселей в файле main.scss:

.block {
	...
	.block__text {
		font-size: 80px;
	}
}

Идеально! но как же будет выглядеть этот код в формате CSS? а вот так:
*/

.block {
	font-size: 50px;
	line-height: 60px;
	padding: 30px;
}

.block span {
	color: green;
}

.block .block__text {
	font-size: 80px;
}

/*
Сразу видно, что кода в таком формате становится много. На несколько строк больше, чем в
синтаксисе SCSS. Но код сработает в любом случае, и размер шрифта в div'е сильно увеличится.
Кроме того, вложенность span'а всё также продолжает работать, ибо мы обратились ко ВСЕМ тегам
span, что находятся в div'е с классом "block", и не важно, стоит ли правило для span раньше
чем правило для div'а с классом "block__text" или позже него:

Можно так:

.block {
	...
	span {
		...
	}

	.block__text {
		...
	}
}

А можно так:

.block {
	...
	.block__text {
		...
		span {
			...
		}
	}
}

Я заменю код в main.scss на тот, в котором span хранится ВНУТРИ правила для div'а с классом
block__text, потому что так будет правильней, ведь span физически хранится внутри div'а.
Идем дальше! - ко вложенности Sass применимы всё те же операторы, что и применимы для CSS,
а также новые операторы. Вы спросите: "о чем идет речь, молодой человЭк?", а я вам отвечу,
что допустим у нас в index.html есть два параграфа с текстами - "Параграф №1" и "Параграф
№2" соответственно. И я хочу украсить эти параграфы. Добавим следующие стили в main.scss:

.block {
	...
	p {
		color: red;
	}
	...
}

Добавив строку p {color: red;}, ВСЕ параграфы на нашей странице станут красными. Но вдруг
мне резко захотелось изменить цвет на красный только у первого параграфа, чтобы только он
был красным. Как же мне этого добиться? очень просто! в CSS у нас, если вы помните, был
селектор вложенности, который выбирал элементы первого уровня (те, что идут сразу в самом
элементе) - знак больше (>). Чтобы выбрать параграф первого уровня, мы должны были прописать
что-то вроде следующего:
*/

.block > p {
	color: red;
}

/*
Этот код сработает одновременно и в CSS, и в SCSS, но мы же ведь знаем, что длинный код =
плохой код! мы можем его сократить следующим образом:

.block {
	...
	>p {
		color: red;
	}
	...
}

Заходим в браузер после добавления такого кода и... УРА! - цвет первого параграфа изменен!
То есть мы просто берём и прописываем	оператор, а после него ставим селектор типа, класса или
любой другой. После работы этого кода, первый параграф окрасится в красный цвет, а второй - не
окрасится, потому что он находится на другом уровне вложенности. Идём дальше!

Есть и множество других операторов, которые очень редко используются и говорить о них мы по этой
причине не будем, но поговорим мы о НОВОМ интересном операторе, который ускорит нашу работу В РАЗЫ.
Это оператор and (&). Простая заковырина, которая обозначает слово and (и). Как она применяется?
Ну как сказать.. если говорить простым языком, то Sass (без разницы, в синтаксисе SCSS или нет)
заменяет значок and, амперсанд (эта закорючка так и называется) на родителя, если говорить про
наш случай, то обозначать он будет ".block". Допустим, что у нас есть в index.html ссылка c классом 
link, ведущая на какой нибудь сайт, гугл например. Я хочу сделать её синей и добавить ей нижнее 
подчеркивание, не вписывая правило в одно общее, где родитель div с классом "block" - вместо этого
я создам новое правило, специально для ссылки и закомменитирую параграфы в index.html и стили для
них в main.scss, ибо они мне уже не нужны:
*/

.link {
	color: blue;
	text-decoration: underline;
}

/*
A.S: В принципе, в SCSS будет написано то же самое, так что записывать то, как это будет выглядить
в синтаксисе SCSS - смысла нет.

Далее, я хочу изменить её цвет (ссылки) на какой нибудь другой, НО только при наведении на неё!
В CSS мы бы сделали это следующим образом: 
*/

.link:hover {
	color: green;
}

/*
Такая запись сработает как в CSS, так и в SCSS, но мы же ведь можем укоротить её используя оператор
and (&)! напишем следующее в main.scss:

.link {
	&:hover {
		color: green;
	}
}

После этого, в style.css появляется следующая строчка в конце: ".link:hover {...}", что означает,
что наш амперсанд (оператор "и") превратился в слово link, а link - родительский элемент, ссылка.
Заходим в браузер - меняется цвет ссылки при наведении! причем тот же самый фокус сработает и с
любым другим псевдо-классом/псевдо-элементом, писать их мы можем ВНУТРИ родительского правила и
просто ставить оператор "и", ничего сложного! повторяю: оператор амперсанд просто берет и ищет
название родителя, и после того как его найдет - вставляет вместо себя. Но этот оператор можно
использовать еще тогда, когда у нас несколько классов для одного тега. Например, у нашего div'а
с класом "block" есть другой класс, "parent--block". Внутри правила для элемента с классом .block
в нашем .main.scss мы ставим оператор амперсанд и после него прописываем точку, а уже после точки
класс "parent--block", применяя к нему какие-то свойства:

.block {
	...
	&.parent--block {
		font-size: 55px;
	}
}

Таким образом, размер ссылки на нашей странице будет увеличен с 50-ти пикселей на 55 пикселей. А
вот в нашем style.css файле в это время появился следующий кусок кода:
*/

.block.parent--block {
	font-size: 55px;
}

/*
Как мы видим, в файле style.css появился селектор двух классов. И кстати, приоритетность такого
селектор не увеличивается этой записью - мы просто берем и указываем, что к элементу с классами
"block" и "parent--block" применяются следующие такие-то да такие-то стили, и всё, не более того!
И еще один интересный пример использования оператора амперсанд: представим, что у нас на странице
есть ещё одна ссылка, которая находится ВНЕ элемента с классом "block" и ведет она на сайт youtube,
но помимо всего этого, размеры ссылок стали равными - 25 пикселей у каждой ссылки, а также они 
поменялись местами - ссылка ведущая на youtube находится В div'е с классом "block", а ссылка на
сайт гугла находится ВНЕ div'а. Я хочу, чтобы ссылка, которая находится в div'е изменила свой размер
с 25-ти пикселей на 35, став больше той, что находится вне, и кроме того - уж ссылка ведет на ютуб,
то при hover'е её цвет должен быть красным - ютуб, как  никак. Вы скажете: "а ты просто пропиши
внутри правила для элемента div с классом «block» правило для элемента с классом «link» и поменяй
его размер там же, после этого внутри уже правила для «link» добавь специальный :hover, используя
оператор амперсанд" - и вы будете абсолютно правы, если так скажите! это будет самым верным решением
задачи, но что, если нам хочется по другому? например, изменить стили в правиле для ссылки с классом
"link"? в таком случае, мы можем сделать вот так:

.link {
	...
	.block & {
		font-size: 35px;
		&:hover {
			color: red;
		}
	}
*/

/*
Готово, заходим в браузер, смотрим: размер первой ссылки стал больше, а теперь наводим мышкой на
неё - цвет изменился на красный, всё получилось! но что значит наша запись? сейчас я покажу вам,
что появилось в файле style.css после этого кода:
*/

.block .link {
  font-size: 35px;
}
.block .link:hover {
  color: red;
}

/*
Вот и всё, ничего интересного. Мы просто обращаемся к ссылке внутри div'а.block и меняем её размер
на такой-то, а после этого меняем её цвет при hover'е на красный. Также, вместо амперсандов у нас 
подставляется название текущего родителя, в нашем случае это "link". Таким образом, при помощи
простой вложенности и оператора амперсанд мы можем делать легкий и понятный (ну, тут уже кому как)
код! таким образом, наша "писанина" в формате SCSS конвертируется в понятный для браузера код, в
его родной CSS. Идём дальше!

СУПЕРСИЛА №2 - Переменные

Второй суперсилой препроцессора SCSS являются переменные. Я думаю, что объяснять вам, что такое
переменные - смысла нет. Если вкратце, то переменная это, то что хранит в себе некое значение.
В SCSS она может хранить в себе что угодно, вы только представьте: цвета, текстовые значения (те
же цвета в текстовом виде, red например) и так далее! перейдем к сути. Переменные в препроцессоре
создаются при помощи знака доллара (миллионеры, что поделать, деньги же надо куда-то девать :D). 
После него мы придумываем и записываем абсолютное любое слово, это будет названием нашей переменной,
по которому мы будем к ней обращаться в будущем. В качестве названия мы можем использовать любое
слово, например, fz - сокращение от font size. А вот после названия переменной ставится двоеточие,
представляете? но вы ни за что не угадаете, что идёт после двоеточия - значение переменной! не
ожидали? но да ладно, ничего! создадим переменную fz в main.scss и в качестве значения передадим
ей число 80 с припиской px:

$fz: 70px;

Готово! теперь эту переменную мы можем использовать в качестве значения определенных свойств, и
делается это также просто, как и создаются сами переменные: берем свойство, прописываем его, ставим
двоеточие и после него знак доллара. После доллара ставится название переменной и... всё! готово!
Ничего трудного. Поэтому я возьму и заменю все значения свойства font-size в нашем SCSS файле на 
переменную fz, как сокращение:

Из этого:

.block {
	...
	.block__text {
		font-size: 80px;
		...
	}
}

.link {
	font-size: 25px;
	...
	.block & {
		font-size: 35px;
		...
	}
}

В это:

.block {
	...
	.block__text {
		font-size: $fz;
		...
	}
}

.link {
	font-size: $fz;
	...
	.block & {
		font-size: $fz;
		...
	}
}

Зайдя после этих действий в браузер мы увидим, что размер ВСЕХ наших ссылок изменился со своих
значений на значение переменной. Теперь, вместо того чтобы менять значение свойства у каждого
элемента по-отдельности, мы можем просто изменить значение нашей переменной! да, если вам
необходимо изменить размер текста на какой-то другой, но при этом вы не хотите менять его
у всех остальных элементов, то можете написать свойство font-size конкретному элементу. "Почему
эта суперсила так полезна?" - могли бы вы меня спросить, читатель, и я отвечу вам, что в большинстве
случаев мы, верстальщики, во многих местах в коде используем свойство font-size с определенным
значением (да и не только это свойство - есть множество других свойств), и бывает так, что нам 
необходимо изменить значение этого свойства у КАЖДОГО элемента на какой нибудь другой. Менять его 
нам приходится вручную, но зачем же так заморачиваться, если можно просто поменять значение 
переменной и дело с концом? в этом и вся суть вопроса. Давайте изменим значение переменной fz на 80:

$fz: 80px;

Готово! заходим в браузер и видим, что размер текста у элементов на странице изменился на тот,
который мы определили в переменной fz, прекрасно, теперь поменяем значение переменной на 100:

$fz: 100px;

Вновь заходим в браузер и смотрим: размер текста у всех элементов, у которых есть свойство
font-size изменился с 80-ти пикселей на 100, отлично! я думаю, что не стоит вам объяснять,
насколько это крутая и полезная суперсила препроцессора SCSS, так как это уже понятно :)
Но останавливаться на одной переменной - глупое решение. Создадим еще три переменные, 1-ая
будет называться color_1, вторая будет называться color_2, третья будет называться color_3 
соответсвенно. У $color_1 значение будет "blue", у переменной $color_2 значение будет "red",
а вот для переменной $color_3 мы в качестве значения поставим "green":

$color_1: blue;
$color_2: red;
$color_3: green;

Шикарно! а теперь заменим значения на значение переменных в тех свойствах, значения которых
соответствую значениям переменных, или говоря проще - если у свойства color есть значение blue,
то убираем его и ставим "$color_1", а если red, то тоже убираем его и ставим "$color_2" и т.д:

Из этого:

.block {
	...
	.block__text {
		...
		span {
			color: green;
		}
	}
}

.link {
	...
	color: blue;
	...
	&:hover {
		color: green;
	}

	.block & {
		...
		&:hover {
			color: red;
		}
	}
}

В это:

.block {
	...
	.block__text {
		...
		span {
			color: $color_3;
		}
	}
}

.link {
	...
	color: $color_1;
	...
	&:hover {
		color: $color_3;
	}

	.block & {
		...
		&:hover {
			color: $color_2;
		}
	}
}

Опять же заходим в браузер и смотрим: ничего не поменялось. Да и не должно было бы как-то
да поменяться, так как никаких изменений мы не внесли - всего лишь заменили значения
свойств color на те же самые, но записанные в отдельные переменные. Вы можете высказать
недовольство, заявив, что писать такие длинные названия переменных не круто, и что "blue",
"red" и "green" было бы легче записать.. и вы в чём-то правы, да. Но представьте, что ваш
код просто огромен, и надо по-быстрому изменить все значения свойства color на другие,
представьте, как это будет трудно и скучно! переменные избавляют нас от таких трудностей
тем, что мы заменив значение у одной переменной, меняем его ВЕЗДЕ, где только можно..
это просто потрясающе, не так ли? :) А теперь о том, что я появилось в файле "style.css" и
почему я не пишу о том, что там изменилось: добавилось там не много чего: лишь в некоторых
местах изменились значения свойств font-size и color. А что касается того, почему я не
пишу о изменениях - всё потому, что писать нечего. Да, просто нечего! всё то, что я пишу
в SCSS-файле повторяется в CSS-файле, просто в привычном нам простом синтаксисе и много
где, т.е во многих местах. Хорошо, идём дальше!

СУПЕРСИЛА №3 - Импорт

Следующая суперсила препроцессора Sass - импорт других стилей, о которой мы сейчас и
поговорим. Начнем с нашего обнуляющего файла, "main_resetter". Вообще, этот обнуляющий
стили код должен был быть ВНУТРИ нашего CSS файла, но я самостоятельно вынес его в другой
файл, но да ладно. Представим, что такой код у нас в самом рабочем файле. При каждом
запуске редактора кода и самого файла, с самого начала мы видим наш код для обнуления (так
как такие обнуляшки прописывают в самом верху) и только после него видим уже всё остальное.
Мы бы в таком случае могли взять и сделать новый файл, в который добавили бы наш обнуляющий
код, и это было бы правильным решением - но что если он написан на SCSS? тогда мы можем
буквально ВШИТЬ его в наш основной SCSS файл! для этого я взял и удалил наш обнуляющий
файл и заранее скопировал его код в другой файл, "nullstyle.scss". В нём хранится весь
наш код-обнуляшка, больше добавить нечего :D хорошо, а теперь приступим к самому импорту.

Для того, чтобы импортировать один файл в другой, используется команда @import. После того
как мы прописали эту команду, необходимо поставить кавычки и внутрь них записать название
файла, который вы хотите импортировать, пример:

@import "nullstyle.scss";

Эту запись я уже добавил в свой основной SCSS файл, всё прекрасно! :) в style.css файле
появился наш огромный код, который используется для обнуления. Это легко проверить, нам
достаточно просто зайти в него, но не суть. Достаточно просто задуматься и понять, что
SCSS действительно невероятно силён! благодаря одной строчке кода, мы взяли и внесли
другой многострочный и монолитный блок кода в наш стилевой файл! Таким образом мы можем
экономить место в нашем стилевом файле и фрагментировать его. Что значит фрагментировать?
Представьте, что у нас есть многостраничный сайт, в котором есть целых 15 страниц, и у
каждой страницы может быть свой SCSS файл, и нам потом в процессе разработки и поддержки
проекта будет легко найти нужный стиль: просто открываем файл с нужной страницей и вносим
правки. Или можно выносить какие-то стили в блоки, как наш обнуляющий код - мы вынесли его
в отдельный блок, а затем и в отдельный файл nullstyle.scss. Также следует отметить, что
после создания SCSS файла с обнуляющими стилями, у нас появился ещё и простой CSS файл - я
его "ликвидировал" за ненадобностью, так как всё будет идти в style.css.

Еще очень важно отметить, что когда мы изменяем любой импортированный в main.scss файл
и нажимаем "Сохранить", сохраняем файл, но сохранение и обработка происходят сразу ИЗ
ФАЙЛА main.scss. О чём вообще идёт речь? на практике я ничего показывать не буду, но
объясню словесно - допустим, что мы изменили nullstyle.scss, добавили новых цветов, ну,
изменили размер текста, сам шрифт, отступы, позиционирование и прочее-прочее. Изменили,
сохранили. Хорошо, но скомпилировался у нас сразу main.scss! мы изменили nullstyle, а вот
компиляция и общее сохранение (даже если ничего не менялось) произошло конкретно в main.
Это легко проверить, добавив чего нибудь нового в nullstyle и сохранив его - компиляция
происходит непосредственно в файле main.scss и все стили меняются (или добавляются, это
зависит от того или иного действия) в style.css. Почему так происходит? потому что наш
nullstyle.scss ПОДКЛЮЧЁН, ВШИТ в main.scss и является его.. ну, частью так сказать. И
это тоже на самом деле легко проверить, если взять и зайти в style.css, там не только
находится наш ОСНОВНОЙ код, но и (в самом начале) код для обнуления стилей. То есть так
получается, что нам не нужно менять nullstyle.scss, потом как-то обрабатывать main.scss,
нет, всё происходит автоматически. Эти файлы становятся будто связанными, неотъемлемыми
частями друг друга. А мы идём дальше, к следующей суперсиле SCSS!

СУПЕРСИЛА №4 - Шаблоны

Следующая суперсила SASS (в синтаксисе SCSS) - это шаблоны. Шаблоны это тоже очень-очень
крутая суперсила, которая значительно ускоряет процесс разработки сайта. Чем она нам
так полезна? - допустим, что у нас есть две ссылки на странице. Действительно, у нас
и в правду есть две ссылки на странице, но что, если у одной из них другой класс? я
изменил класс второй ссылки на link-2, теперь это абсолютно другая ссылка, к которой
не применяются никакие стили. Мы это по быстрому исправим, добавив малую стилизацию
второй ссылке:

.link-2 {
	font-size: 80px;
}

Хорошо, теперь к сути. Представим себе, что у нас по дизайну есть некий шаблон - к
примеру, у нас все ссылки на сайте имеют пунктирное подчеркивание, а не простое нижнее,
такой вот у них стиль. Да цвета могут быть разными, размер тоже, но все они без какого
либо исключения имеют одно и то же пунктирное подчеркивание. В таком случае, мы можем
абсолютно каждой ссылке на странице добавлять по пунктирному подчеркиванию, но кроме
этого можно использовать ШАБЛОН! как шаблоны создаются? они создаются практически так
же как и переменные, но у них не ставится знак доллара - у них ставится знак процента.
После того как поставили знак процента, прописываем название шаблона. Я назову шаблон
tplborder (не знаю, что это значит, но это название придумал Жека и.. и ладно), и после
всего этого ставятся фигурные скобки. В принципе, синтаксис такой же как и у селектора
по классу, например, просто вместо точки ставится знак процента:

%tplborder {
	...
}

Прекрасно, теперь необходимо заполнить шаблон, то есть применить те параметры, которые
мне нужны. У нас это будет параметр border-bottom с определенным значением:

%tplborder {
	border-bottom: 5px dashed red;
}

Шедеврально, и вот сейчас надо подключить этот шаблон к ссылкам. Для тех ссылок, к которым
мы хотим применить наш шаблончик, применяется команда @extend. Она работает практически (ну,
по моему мнению) также, как и команда @import, но вместо стилевого файла подключается некий
шаблон. Если вы человек находчивый, то вы наверняка уже догадались, что после этой команды
надо прописать само название шаблона. Так и есть, просто пишем название шаблона и всё (со
знаком процента):

.link {
	...
	@extend %tplborder;
}

Готово! для того, чтобы увидеть, как бы у нас отобразился шаблон в виде CSS, достаточно
просто зайти в файл style.css, в самом верху, сразу после нашего обнуляющего кода появился
отдельная запись с селектору по классу со значением, которое мы записали нашему шаблону:

.link {
	border-bottom: 5px dashed red;
}

Теперь, когда мы начнём менять код внутри шаблона, то в том месте, где добавился наш код,
и он тоже появится! какие бы стили мы не добавляли в шаблон, они незамедлительно будут
применяться ко всем селекторам, к которым мы его подключили:

Добавили стили в шаблон:

%tplborder {
	font-size: 110px;
	...
}

Он добавился в ту самую запись:

.link {
	font-size: 110px;
	...
}

Но тут стоит добавить, что подключение шаблонов идёт как БАЗОВОЕ. "Что это значит" - вы
начнёте задаваться вопросом (а может и не начнёте), а я дам ответ на ваш вопрос! это
означает, что сначала подключаются стили, указанные в шаблоне, а затем уже всё остальное,
стили, которые мы с вами и пишем. Но вот это в свою очередь говорит о том, что базовый
стиль у нас применяется в первую очередь, но если нам надо что-то переписать, то мы просто
переписываем это поверх свойства и никаких проблем не имеем. А теперь к тому, что появилось
в браузере: а в нашем с вами браузере появились изменения, читатель! к первой ссылке таки
применились те стили, которые мы задали в шаблоне, то есть у неё всё таки появилось нижнее
красное подчеркивание, которое мы ему задали через border-bottom. Также, этот же шаблон
можно применить и ко второй ссылке:

.link-2 {
	...
	@extend %tplborder;
}

Заходим в бразуер и видим, что у второго элемента ссылки появилась точно такая же граница,
как и у первой ссылки. Причем если нам по какой-то причине понадобится изменить, допустим,
цвет у нижней границы во второй ссылке, то мы можем это сделать напрямую в её же правиле:

.link-2 {
	...
	border-bottom: 5px dashed $color_3;
}

Заходим в бразуер и смотрим - у второй ссылки изменился цвет подчеркивания. Таким образом
сразу становится понятно, что при таких случаях, когда у элемента должно быть что-то такое,
что есть у других элементов и прописано в шаблоне, но другого цвета или же размера - мы
всегда можем быстро взять и так же заменить значение какого-то свойства, взятое из шаблона.
Также, если зайти в файл style.css, можно увидеть, что те элементы, в которых используется
этот шаблон, используют одно правило, но их селекторы разделяются запятой. Если вам не
понятно то, что я написал, то просто взгляните на это:

.link, .link-2 {
	...
}

Таким образом сразу становится понятно, что элементы использующие один и тот же шаблон не
пишутся по-отдельности, нет, напротив, они используют то же самое стилевое правило, но
только если шаблон у них тот же самый, и это невероятно умно - благодаря этому у нас в
файле происходит огромная экономия места! дальше я хочу рассказать о том, что может
произойти в том случае, если шаблон создается в самом низу нашего файла. В таком случае,
во первых, в style.css наш шаблон будет создаваться в самом низу, так что он по факту
будет просто перезаписывать то, что у нас находится в оригинальной записи, то есть всё
то, что было ДО шаблона:

Что будет в style.css, если шаблон создавать в самом низу:

...
.link, .link-2 {
	...
}


И если после этого зайти в браузер, то цвет нижнего подчеркивания у второй ссылки изменится
на красный, поскольку код в шаблоне ПЕРЕЗАПИСЫВАЕТ всё то, что было до него, код шаблона
идёт после всего остального. А что будет, если создать шаблон, но не использовать его? ну, 
в таком случае он у нас просто нигде не будет появляться! да, всё именно так, он просто не 
появится в style.css. Звучит эта ситуация следующим образом: мы создаём наш шаблон, не 
важно где именно, но ни к какому элементу мы его не применяем. Соответственно получается 
так, что шаблон есть, но где-то там, "в запасах", поэтому в style.css его нет. Появится он 
и начнёт работать лишь в том случае, если мы какому-то элементу "подсунули" наш шаблон, и 
никак иначе.

Помимо прочего, в SCSS есть еще одна важная особенность, связанная с созданием шаблонов:
шаблоны необязательно создавать через знак процента! давайте представим ситуацию. Нам
нужен шаблон. Не важно, где вообще этот шаблон будет находится, он нам нужен. Код внутри
него будет менять начертание нашего,
называться он будет tplborder-class. А теперь о том, как создать шаблон без знака процента
и что для этого нужно - ничего для этого не нужно, просто замените процент на простую
точку. Да, просто точка! таким образом мы создаём класс, но в HTML он никак не используется
(но использовать его можно):

Создание шаблона через точку в main.scss:

%tplborder {
	...
}

.tplborder-class {
	...
}

Так, а остальное - позже! (бум не произошел, штош..)
*/